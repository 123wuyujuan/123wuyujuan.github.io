{"meta":{"title":"唐泽雪穗","subtitle":"","description":"唐泽雪穗的个人网站","author":"Yujuan Wu","url":"https://123wuyujuan.github.io","root":"/"},"pages":[{"title":"Gallery","date":"2020-10-17T16:14:18.000Z","updated":"2020-10-17T16:16:49.313Z","comments":true,"path":"gallery/index.html","permalink":"https://123wuyujuan.github.io/gallery/index.html","excerpt":"","text":""},{"title":"About","date":"2020-10-17T16:12:04.000Z","updated":"2020-10-18T02:57:30.183Z","comments":true,"path":"about/index.html","permalink":"https://123wuyujuan.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"CSRF攻击和防范","slug":"CSRF攻击","date":"2020-10-30T01:19:31.635Z","updated":"2020-11-01T16:34:11.995Z","comments":true,"path":"uncategorized/CSRF攻击/","link":"","permalink":"https://123wuyujuan.github.io/uncategorized/CSRF%E6%94%BB%E5%87%BB/","excerpt":"","text":"CSRF 攻击方式CSRF 跨站请求伪造，通过诱导受害者进入第三方网站，在第三方网站中向被攻击网站发送跨站请求，利用受害者在被攻击网站已经获取的注册凭证，绕过后台用户验证，冒充用户操作。 一个典型的CSRF攻击有着如下的流程： 受害者登录a.com，并保留了登录凭证（Cookie） 攻击者引诱受害者访问了b.com b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带a.com的Cookie a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求 a.com以受害者的名义执行了act=xx 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作 防御方案CSRF 有三种防御方法： 用户操作限制，验证码机制 请求来源限制：限制 HTTP Referer Token 验证机制，请求数据字段中添加 token， 响应请求时校验其有效性 对于第一种方案，影响用户体验，第二种方案成本低，但并不能保证 100% 安全， 第三种方案是目前最合适的方案。 HTTP Referer 防御机制在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，如果黑客要对网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到正常网站时，该请求的 Referer 是指向黑客自己的网站。 因此，只需要对每一个请求验证其 Referer 值，如果 Referer 是来自其他网站的话，就说明可能遭到了 CSRF 攻击，拒绝请求。 缺陷使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，然而，每个浏览器产商对于 Referer 的实现可能会有差别，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。 即使使用最新的浏览器，用户仍然可以设置浏览器使其在发送请求时不再提供 Referer。因为有些用户认为记录访问来源会侵犯他们的隐私。当他们正常访问网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。 Token 验证机制防御CSRF 攻击完全是因为黑客可以伪造用户的请求，请求中所有的用户验证信息全部存在 Cookie 中，黑客可以再不知道这些验证信息的情况下直接利用用户的 Cookie 通过验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。 在 HTTP 头中加入自定义属性可以在 HTTP 请求中加入一个随机产生的 token，放到自定义的属性里，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。 后端随机生成一个 Token 并保存在 Session 中，并把这个 Token 返回给前端 前端发起请求时把 Token 带到请求数据或者请求头中发送给后端 后端校验前端传入的 Token 和后端 Session 中的 Token 是否一致 NodeJS 下的 Token 验证NodeJS 不具备 Session 的功能，可以借助 Cookie 来传送 Token 后端随机生成一个 Token，基于这个 Token 利用 SHA-56 等散列算法生成密文 后端将 Token 和生成的密文都设置为 Cookie，并返回给前端 前端发请求时，从 Cookie 中获取 Token，把 Token 加入请求数据或请求头 后端校验 Cookie 中的密文和前端请求带过来的 Token，进行正向散列验证","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://123wuyujuan.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"web安全","slug":"web安全","permalink":"https://123wuyujuan.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"用HTML和JavaScript模拟XSS攻击","slug":"XSS攻击","date":"2020-10-29T09:49:48.249Z","updated":"2020-10-30T07:53:52.378Z","comments":true,"path":"uncategorized/XSS攻击/","link":"","permalink":"https://123wuyujuan.github.io/uncategorized/XSS%E6%94%BB%E5%87%BB/","excerpt":"","text":"HTML文件： &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;body&gt; &lt;form method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;input&quot;/&gt; &lt;input type=&quot;submit&quot; onclick=&quot;onSubmit(input.value)&quot; value=&quot;提交&quot;/&gt; &lt;/form&gt; &lt;/body&gt; &lt;!-- &lt;script src=&quot;./xss.js&quot;&gt;&lt;/script&gt; --&gt; &lt;/html&gt;&lt;script&gt; function onSubmit(value) &#123; document.write(value) console.log(value) &#125;&lt;/script&gt; 然后在网页中的 input 框输入普通字符串： 网页上显示正常字符串 123 接着输入 JavaScript 代码：&lt;script&gt;alert(&#39;XSS攻击&#39;)&lt;/script&gt; 提交之后显示： 打开调试页面： 甚至可以从远端加载 JavaScript 文件进行攻击，我这里加载的是同级目录下的 xss.js 文件： // xss.jslet i = 5while(i &gt; 1)&#123; alert(&#x27;反射型XSS攻击&#x27;) i--&#125; 输入框中输入 &lt;script src=&quot;./xss.js&quot;&gt;&lt;/script&gt;，提交后会显示4次警告框： XSS 注入的方法 HTML 内嵌文本中，以 script 标签注入代码 在内联 JavaScript 中，拼接的数据突破了原本的限制 在标签属性中，恶意内容包含引号，突破属性值的限制，注入其他属性或标签 在标签的 href 、src 属性中，包含 javascript:可执行代码 在 onload onerror onclick等事件中，注入不受控制的代码 background-image:url(&quot;javascript:...&quot;); 的代码（新版本浏览器已经可以防范） 在 style 属性和标签中，包含类似 expression(...) 的 CSS 表达式代码（新版本浏览器已经可以防范） XSS 攻击分类 存储型 攻击步骤： 攻击者将恶意代码提交到目标网站的数据库中。 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等 反射型 攻击步骤： 攻击者构造出特殊的 URL，其中包含恶意代码。 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作 常见于通过 URL 传递参数的功能，如网站搜索、跳转等 DOM 型 攻击步骤： 攻击者构造出特殊的 URL，其中包含恶意代码。 用户打开带有恶意代码的 URL。 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。 XSS 攻击防范XSS 攻击的本质是：恶意代码未经过滤，与正常的代码混在一起被执行，由于直接在终端执行，所以能够直接获取用户信息，或者利用这些信息冒充用户发起请求 来源： 来自用户的 UGC 信息 来自第三方的链接 URL 参数 POST 参数 Referer （可能来自不可信的来源） Cookie （可能来自其他子域注入） 大致过程为：攻击者提交恶意代码，浏览器执行恶意代码 前端过滤用户输入一旦绕过前端过滤，直接构造请求，就无法防范 后端过滤用户输入 用户的输入内容可能同时提供给前端和客户端，而一旦经过了 escapeHTML()，客户端显示的内容就变成了乱码( 5 &lt; 7 )。 在前端中，不同的位置所需的编码也不同。 当 5 &lt; 7 作为 HTML 拼接页面时，可以正常显示： &lt;div title=&quot;comment&quot;&gt;5 &amp;lt; 7&lt;/div&gt; 当 5 &lt; 7 通过 Ajax 返回，然后赋值给 JavaScript 的变量时，前端得到的字符串就是转义后的字符。这个内容不能直接用于 Vue 等模板的展示，也不能直接用于内容长度计算。不能用于标题、alert 等。 所以，输入侧过滤能够在某些情况下解决特定的 XSS 问题，但会引入很大的不确定性和乱码问题。在防范 XSS 攻击时应避免此类方法。但对于数字、url、电话邮件地址等可以进行过滤。 防止浏览器执行恶意代码存储型和反射型 XSS 攻击 纯前端渲染 明确告诉浏览器下面的内容是文本（.innerText），还是属性（.setAttribute），样式（.style） 无法预防 DOM 型 XSS 漏洞 （onload 、onerror 、href:javascript:xxx） HTML 转义 采用转移策略，对特殊字符进行转义。转义库：org.owasp.encoder DOM 型 XSS 攻击 小心使用.innerHTML、.outerHTML、document.write()，尽量用 .textContent、setAttribute()。 如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患 其他防范方法Content Security Policy严格的 CSP 在 XSS 的防范中可以起到以下的作用： 禁止加载外域代码，防止复杂的攻击逻辑。 禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。 禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。 禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。 合理使用上报可以及时发现 XSS，利于尽快修复问题。 输入内容长度控制对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度。 HTTP-only Cookie禁止 JavaScript 读取敏感 Cookie，让攻击者注入后无法取得 Cookie。 验证码防止脚本冒充用户。 XSS 漏洞检测 手动检测 jaVasCript:/*-/*`/*\\`/*&#x27;/*&quot;/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//&lt;/stYle/&lt;/titLe/&lt;/teXtarEa/&lt;/scRipt/--!&gt;\\x3csVg/&lt;sVg/oNloAd=alert()//&gt;\\x3e 在输入框中提交或者拼接到 url 参数上进行检测 自动扫描 Arachni、Mozilla HTTP Observatory、w3af","categories":[],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://123wuyujuan.github.io/tags/Web%E5%AE%89%E5%85%A8/"}]},{"title":"解决方法：浏览器账号密码自动保存","slug":"web安全","date":"2020-10-28T04:23:52.000Z","updated":"2020-10-28T04:24:13.092Z","comments":true,"path":"uncategorized/web安全/","link":"","permalink":"https://123wuyujuan.github.io/uncategorized/web%E5%AE%89%E5%85%A8/","excerpt":"","text":"浏览器账号密码自动保存在用户在web页面登录时，浏览器会问用户是否保存账号密码，如果用户点击保存，那么在下次登录的时候可能会出现下面两种情况： 账号密码手动回填 账号密码自动回填 如果用户在公共电脑上顺手点了保存，那么之后使用此电脑的人就很容易获取到用户的账号信息。虽然这样的设计方便了用户登录，但也很容易导致安全隐患。 页面的处理方式","categories":[],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://123wuyujuan.github.io/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"前端","slug":"前端","permalink":"https://123wuyujuan.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"DNS攻击","slug":"DNS攻击","date":"2020-10-28T04:16:38.000Z","updated":"2020-10-28T04:22:39.515Z","comments":true,"path":"uncategorized/DNS攻击/","link":"","permalink":"https://123wuyujuan.github.io/uncategorized/DNS%E6%94%BB%E5%87%BB/","excerpt":"","text":"DNS request Flood 攻击DNS Reply Flood 攻击DNS 查询通常基于 UDP 协议，而 UDP 协议是无连接的，当 DNS 服务器收到 DNS reply报文时，不管自己有没有发出过解析请求，都会对 DNS reply 报文进行处理。DNS Reply Flood 就是黑客发送大量 DNS reply 报文给 DNS 服务器，导致消耗大量缓存服务器资源，无法正常解析 DNS 授权服务器发送的 DNS reply报文。 源认证DNS Reply Flood 的源 IP 地址通常是伪造的，所以可以通过判断源 IP 地址的真假来防范攻击。这种方式通过构造一个 DNS request报文进行认证。 DNS reply 报文超过阈值，收到 DNS reply 报文后会重新构造一个 DNS request 报文，并记录构造查询报文的Query ID和源端口号。 如果是真实源，则会回应 DNS reply 报文，如果与之前记录的 Query ID 和源端口号匹配成功，则加入白名单，认证成功。之后发送的报文直接通过。 如果是虚假源，则不会回应这个 DNS request 报文，认证不通过。 DNS 反射攻击 一种更高级的 DNS Reply Flood，攻击目标是客户端而不是 DNS 缓存服务器，并且 DNS 请求是真实的 会话检查利用防火墙的会话表机制，DNS 交互过程中，DNS request 报文首包建立会话，保存五元组信息。当收到 DNS reply 报文时，匹配会话表，如果命中才允许通过。 利用限速防范 DNS Request Flood 和 DNS reply攻击 域名限速 如果某个域名的DNS请求或回应报文速率过高，可以针对这个域名进行限速。 源 IP 地址限速 如果某个源IP地址域名解析的速率过大，就可以有针对性的对这个源IP地址进行限制，这样也不会对其他源有影响。 DNS 缓存投毒攻击","categories":[],"tags":[{"name":"DNS","slug":"DNS","permalink":"https://123wuyujuan.github.io/tags/DNS/"},{"name":"DDos","slug":"DDos","permalink":"https://123wuyujuan.github.io/tags/DDos/"},{"name":"Web安全","slug":"Web安全","permalink":"https://123wuyujuan.github.io/tags/Web%E5%AE%89%E5%85%A8/"}]},{"title":"ant-design-vue 插槽使用","slug":"ant-design vue 插槽使用","date":"2020-10-20T06:42:51.000Z","updated":"2020-10-28T06:30:59.028Z","comments":true,"path":"uncategorized/ant-design vue 插槽使用/","link":"","permalink":"https://123wuyujuan.github.io/uncategorized/ant-design%20vue%20%E6%8F%92%E6%A7%BD%E4%BD%BF%E7%94%A8/","excerpt":"","text":"&lt;a-table :columns=&quot;columns&quot; :dataSource=&quot;dataList&quot; :loading=&quot;loading&quot; :pagination=&quot;false&quot; :rowKey=&quot;(record,index) =&gt; index&quot;&gt; &lt;template slot=&quot;duty&quot; slot-scope=&quot;text, record, index&quot;&gt; &lt;span v-if=&quot;text == &#x27;general&#x27;&quot;&gt;普通员工&lt;/span&gt; &lt;span v-if=&quot;text == &#x27;expert&#x27;&quot;&gt;专家&lt;/span&gt; &lt;span v-if=&quot;text == &#x27;admin&#x27;&quot;&gt;管理员&lt;/span&gt; &lt;/template&gt; &lt;template slot=&quot;status&quot; slot-scope=&quot;text, record, index&quot;&gt; &lt;span v-if=&quot;text == &#x27;1&#x27;&quot;&gt;正常&lt;/span&gt; &lt;span v-if=&quot;text == &#x27;0&#x27;&quot;&gt;失效&lt;/span&gt; &lt;/template&gt; &lt;template slot=&quot;action&quot; slot-scope=&quot;text, record, index&quot;&gt; &lt;a-button type=&quot;primary&quot; size=&quot;small&quot; @click=&quot;editUser(record)&quot;&gt;编辑&lt;/a-button&gt; &lt;/template&gt; &lt;/a-table&gt; // script 部分data()&#123; return &#123; columns:[ &#123; title: &#x27;用户账号&#x27;, dataIndex: &#x27;username&#x27;, &#125;, &#123; title: &#x27;姓名&#x27;, dataIndex: &#x27;name&#x27;, &#125;, &#123; title: &#x27;角色&#x27;, dataIndex: &#x27;duty&#x27;, scopedSlots: &#123;customRender: &#x27;duty&#x27;&#125; &#125;, &#123; title: &#x27;状态&#x27;, dataIndex: &#x27;status&#x27;, scopedSlots: &#123;customRender: &#x27;status&#x27;&#125; &#125;, &#123; title: &#x27;操作&#x27;, dataIndex: &#x27;action&#x27;, scopedSlots: &#123;customRender: &#x27;action&#x27;&#125;, &#125;], dataList: [], loading: false, &#125; &#125;, created()&#123; this.getList() &#125;, methods: &#123; getList()&#123; this.loading = true; this.$http.get(&#x27;/getUsers.do&#x27;).then(res =&gt; &#123; if(res)&#123; this.dataList = res || [] &#125; this.loading = false; &#125;).catch(err =&gt; &#123; console.log(err) &#125;) &#125;, editUser(record)&#123; this.$refs.addModal.showModal(record) &#125;, &#125; 1.columns 定义table 表头,以及和 dataList 的字段对应,2. dataSource 为数据源,是一个数组,3.loading 加载时loading,数据请求前设置 true,请求完成后设置 false,4.插槽的使用很多情况下,后端返回的数据是 数字,前端需要展示文字,这事使用插槽就会非常方便1.首先,在 columns 中需要的部分添加 scopedSlots: {customRender: ‘status’}2.table 中添加标签 &lt;template slot=&quot;status&quot; slot-scope=&quot;text, record, index&quot;&gt; &lt;span v-if=&quot;text == &#x27;1&#x27;&quot;&gt;正常&lt;/span&gt; &lt;span v-if=&quot;text == &#x27;0&#x27;&quot;&gt;失效&lt;/span&gt;&lt;/template&gt;1234 customRender 的值和slot 的值相对应,slot-scope 中 text就是status的值(text可以自定义,key,item都可以), record 代表text所在的对象,可以通过 record 拿到该行的其他值. 比如 editUser(record)&#123; this.$refs.addModal.showModal(record)&#125;,123 把record作为参数传递,编辑改用户信息.","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://123wuyujuan.github.io/tags/JavaScript/"},{"name":"vue","slug":"vue","permalink":"https://123wuyujuan.github.io/tags/vue/"}]},{"title":"【解决方法】hexo g 报错 \"OperationalError:' EPERM:'  operation not permitted, unlink …\"","slug":"hexo-错误","date":"2020-10-19T08:10:50.000Z","updated":"2020-10-19T08:48:49.276Z","comments":true,"path":"uncategorized/hexo-错误/","link":"","permalink":"https://123wuyujuan.github.io/uncategorized/hexo-%E9%94%99%E8%AF%AF/","excerpt":"","text":"运行 hexo g 报错如下： FATAL &#123; err: [OperationalError: EPERM: operation not permitted, unlink &#39;F:\\blog\\public\\uncategorized\\newpaper&#39;] &#123; cause: [Error: EPERM: operation not permitted, unlink &#39;F:\\blog\\public\\uncategorized\\newpaper&#39;] &#123; errno: -4048, code: &#39;EPERM&#39;, syscall: &#39;unlink&#39;, path: &#39;F:\\\\blog\\\\public\\\\uncategorized\\\\newpaper&#39; &#125;, isOperational: true, errno: -4048, code: &#39;EPERM&#39;, syscall: &#39;unlink&#39;, path: &#39;F:\\\\blog\\\\public\\\\uncategorized\\\\newpaper&#39; &#125;&#125; 网上的解决办法： 权限不够，cmd 使用管理员打开无法解决 删除 C:\\Users\\用户 下 .npmrc 文件无法解决 清除缓存使用 npm clean cache --force 清除缓存 删除 package-lock.json 文件 使用 npm install 重新安装 无法解决 删除 node_modules 目录无法解决 解决方法 网上几乎全是针对 npm 的解决方法，而我的错误是在执行 hexo g 遇到的，且在官网上也没找到解决办法，最后尝试 删除 F:\\blog\\public\\ 下对应的目录 ，重新 hexo g 就不会报错了 他在错误中已经提示了： err: [OperationalError: EPERM: operation not permitted, unlink &#39;F:\\blog\\public\\uncategorized\\newpaper&#39;] 我一开始把 newpaper 文件删除了，但是他又会报另外 uncategorized 下的另一个文件的错，所以需要删除 uncategorized 整个目录，大家根据自己的情况删除就行了，我这个目录下的文件都是根据 source/_posts/ 生成的，删除之后再执行命令 hexo g 会重新生成的~","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://123wuyujuan.github.io/tags/hexo/"}]},{"title":"ES2020新特性","slug":"ES2020新特性","date":"2020-10-18T02:57:16.000Z","updated":"2020-10-19T03:44:12.283Z","comments":true,"path":"uncategorized/ES2020新特性/","link":"","permalink":"https://123wuyujuan.github.io/uncategorized/ES2020%E6%96%B0%E7%89%B9%E6%80%A7/","excerpt":"","text":"[TOC] Dynamic import不同于 ECMAScript2015 中的静态引入模块，Dynamic import 提供了按需引入、计算模块名称和脚本内部执行，并返回一个promise const modulePage = &#x27;page.js&#x27;;import(modulePage) .then((module) =&gt; &#123; module.default(); &#125;);(async () =&gt; &#123; const helpersModule = &#x27;helpers.js&#x27;; const module = await import(helpersModule) const total = module.sum(2, 2);&#125;)(); Promise.allSettled()在promise中有两个重要的方法：promise.all() 和 promise.race()，新增的 promise.allSettled() 方法，返回一个在所有给定的promise都已经fulfilled或rejected后的promise，并带有一个对象数组，每个对象表示对应的promise结果。 用法Promise.allSettled(iterable); 参数 iterable: 一个可迭代的对象，所有成员都是 promise 返回值 只要所有的 promise 都已经完成，无论是 resolve 还是 reject ，所有返回的 promise 都会集中为 一个数组， 数组包含每一个 promise 执行的结果。 每一个结果都是一个对象，包含一个 status 字符串，值为 fulfilled 或者 rejected，此外，还包含一个 fulfilled 时的 value或者 rejected 时的 reson。 const promise1 = Promise.resolve(3);const promise2 = new Promise((resolve, reject) =&gt; setTimeout(reject, 100, &#x27;foo&#x27;));const promises = [promise1, promise2];Promise.allSettled(promises). then((results) =&gt; results.forEach((result) =&gt; console.log(result))); // Object &#123; status: &quot;fulfilled&quot;, value: 3 &#125;// Object &#123; status: &quot;rejected&quot;, reason: &quot;foo&quot; &#125; 浏览器兼容性 String.prototype.matchAll(RegExp)以往，当我们使用 String.prototype.match() 方法时，总是返回一个数组，其中包含所有完全匹配的字符串： const text = &quot;From 2019.01.29 to 2019.01.30&quot;;const regexp = /(?&lt;year&gt;\\d&#123;4&#125;).(?&lt;month&gt;\\d&#123;2&#125;).(?&lt;day&gt;\\d&#123;2&#125;)/gu;const results = text.match(regexp);console.log(results);// [ &#x27;2019.01.29&#x27;, &#x27;2019.01.30&#x27; ] 而 matchAll() 还能够返回所有 Regex 捕获组： const text = &quot;From 2019.01.29 to 2019.01.30&quot;;const regexp = /(?&lt;year&gt;\\d&#123;4&#125;).(?&lt;month&gt;\\d&#123;2&#125;).(?&lt;day&gt;\\d&#123;2&#125;)/gu;const results = Array.from(text.matchAll(regexp));console.log(results);// [// [// &#x27;2019.01.29&#x27;,// &#x27;2019&#x27;,// &#x27;01&#x27;,// &#x27;29&#x27;,// index: 5,// input: &#x27;From 2019.01.29 to 2019.01.30&#x27;,// groups: [Object: null prototype] &#123; year: &#x27;2019&#x27;, month: &#x27;01&#x27;, day: &#x27;29&#x27; &#125;// ],// [// &#x27;2019.01.30&#x27;,// &#x27;2019&#x27;,// &#x27;01&#x27;,// &#x27;30&#x27;,// index: 19,// input: &#x27;From 2019.01.29 to 2019.01.30&#x27;,// groups: [Object: null prototype] &#123; year: &#x27;2019&#x27;, month: &#x27;01&#x27;, day: &#x27;30&#x27; &#125;// ]// ] 可选链操作符（?.）访问属性当要访问嵌套在对象内部的属性时，我们很有可能会遇到这样的错误： Uncaught TypeError: Cannot read property... 所以, 当我们需要访问一个属性时，我们经常会这样写以避免错误: let foo = obj &amp;&amp; obj.foo.// 确认 obj 和 obj.foo 都不是 undefined 或 null 但是即使是这样写也会经常遗漏，且繁琐，如果采用可选链式调用，就可以大量简化这样的前置校验： let foo = obj ?. foolet bar = obj ?. foo ?. bar 有了可选链操作符（?.），在访问 obj.foo.bar 之前，不再需要明确地校验 obj.foo 的状态，一旦遇到 null 或者 undefined就会返回 undefined。 访问方法当我们需要尝试调用一个可能不存在的方法时，可以使用可选链来避免返回异常： let result = obj.someMethod?.(); // ES2019的写法function doSomething(onContent, onError) &#123; try &#123; // ... do something with the data &#125; catch (err) &#123; if (onError) &#123; // 校验onError是否真的存在 onError(err.message); &#125; &#125;&#125;// 使用可选链进行函数调用function doSomething(onContent, onError) &#123; try &#123; // ... do something with the data &#125; catch (err) &#123; onError?.(err.message); // 如果onError是undefined也不会有异常 &#125;&#125; 可选链和表达式使用方括号和属性名的形式来访问属性： let foo = obj?.[&#x27;prop&#x27; + &#x27;Name&#x27;]; 访问数组元素： let item = arr ?. [20]; 可选链不能用于赋值let object = &#123;&#125;;object?.property = 1; // Uncaught SyntaxError: Invalid left-hand side in assignment 浏览器兼容性 空值合并操作符( ?? )通常，当我们需要为判断变量是否为 null ，并为变量赋值时，我们需要利用 逻辑或操作符(||)，当左边为假值时返回右侧操作数： let foo;// foo is never assigned any value so it is still undefinedlet someDummyText = foo || &#x27;Hello!&#x27;;// output: &#x27;Hello!&#x27; 看上去并没有什么问题，但 || 是一个布尔逻辑运算符，左侧的操作数会被强制转换为布尔值，因此，所有的假值（0, ‘’, NaN, null, undefined）都会被转为 false: let count = 0;let text = &quot;&quot;;let number = count || 42;let message = text || &quot;hi!&quot;;console.log(number); // 42，而不是 0console.log(message); // &quot;hi!&quot;，而不是 &quot;&quot; 而使用空值合并操作符可以避免，只有在第一个操作数为 null 或者 undefined 时，才返回第二个操作数： let count = 0;let text = &quot;&quot;;let number = count ?? 42;let message = text ?? &quot;hi!&quot;;console.log(number); // 0console.log(message); // “” 与可选链式操作符之间的关系空值合并操作符针对 undefined 与 null 这两个值，可选链式操作符（?.） 也是如此。在这访问属性可能为 undefined 与 null 的对象时，可选链式操作符非常有用。 let foo = &#123; someFooProp: &quot;hi&quot; &#125;;console.log(foo.someFooProp?.toUpperCase()); // &quot;HI&quot;console.log(foo.someBarProp?.toUpperCase()); // undefined","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://123wuyujuan.github.io/tags/JavaScript/"}]},{"title":"newpaper","slug":"newpaper","date":"2020-10-12T09:18:44.000Z","updated":"2020-10-19T10:29:32.983Z","comments":true,"path":"uncategorized/newpaper/","link":"","permalink":"https://123wuyujuan.github.io/uncategorized/newpaper/","excerpt":"","text":"my first blog!!I’m so excited!!!","categories":[],"tags":[{"name":"test","slug":"test","permalink":"https://123wuyujuan.github.io/tags/test/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-10-10T06:48:50.423Z","updated":"2020-10-19T08:10:17.328Z","comments":true,"path":"uncategorized/hello-world/","link":"","permalink":"https://123wuyujuan.github.io/uncategorized/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment good luck!","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://123wuyujuan.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"web安全","slug":"web安全","permalink":"https://123wuyujuan.github.io/tags/web%E5%AE%89%E5%85%A8/"},{"name":"Web安全","slug":"Web安全","permalink":"https://123wuyujuan.github.io/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"DNS","slug":"DNS","permalink":"https://123wuyujuan.github.io/tags/DNS/"},{"name":"DDos","slug":"DDos","permalink":"https://123wuyujuan.github.io/tags/DDos/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://123wuyujuan.github.io/tags/JavaScript/"},{"name":"vue","slug":"vue","permalink":"https://123wuyujuan.github.io/tags/vue/"},{"name":"hexo","slug":"hexo","permalink":"https://123wuyujuan.github.io/tags/hexo/"},{"name":"test","slug":"test","permalink":"https://123wuyujuan.github.io/tags/test/"}]}