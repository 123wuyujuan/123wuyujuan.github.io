{"meta":{"title":"唐泽雪穗","subtitle":"","description":"唐泽雪穗的个人网站","author":"Yujuan Wu","url":"https://123wuyujuan.github.io","root":"/"},"pages":[{"title":"About","date":"2020-10-17T16:12:04.000Z","updated":"2020-10-18T02:57:30.183Z","comments":true,"path":"about/index.html","permalink":"https://123wuyujuan.github.io/about/index.html","excerpt":"","text":""},{"title":"Gallery","date":"2020-10-17T16:14:18.000Z","updated":"2020-10-17T16:16:49.313Z","comments":true,"path":"gallery/index.html","permalink":"https://123wuyujuan.github.io/gallery/index.html","excerpt":"","text":""}],"posts":[{"title":"ES2020新特性","slug":"ant-design vue 插槽使用","date":"2020-10-20T06:42:51.000Z","updated":"2020-10-20T06:43:57.719Z","comments":true,"path":"uncategorized/ant-design vue 插槽使用/","link":"","permalink":"https://123wuyujuan.github.io/uncategorized/ant-design%20vue%20%E6%8F%92%E6%A7%BD%E4%BD%BF%E7%94%A8/","excerpt":"","text":"&lt;a-table :columns=&quot;columns&quot; :dataSource=&quot;dataList&quot; :loading=&quot;loading&quot; :pagination=&quot;false&quot; :rowKey=&quot;(record,index) =&gt; index&quot;&gt; &lt;template slot=&quot;duty&quot; slot-scope=&quot;text, record, index&quot;&gt; &lt;span v-if=&quot;text == &#x27;general&#x27;&quot;&gt;普通员工&lt;/span&gt; &lt;span v-if=&quot;text == &#x27;expert&#x27;&quot;&gt;专家&lt;/span&gt; &lt;span v-if=&quot;text == &#x27;admin&#x27;&quot;&gt;管理员&lt;/span&gt; &lt;/template&gt; &lt;template slot=&quot;status&quot; slot-scope=&quot;text, record, index&quot;&gt; &lt;span v-if=&quot;text == &#x27;1&#x27;&quot;&gt;正常&lt;/span&gt; &lt;span v-if=&quot;text == &#x27;0&#x27;&quot;&gt;失效&lt;/span&gt; &lt;/template&gt; &lt;template slot=&quot;action&quot; slot-scope=&quot;text, record, index&quot;&gt; &lt;a-button type=&quot;primary&quot; size=&quot;small&quot; @click=&quot;editUser(record)&quot;&gt;编辑&lt;/a-button&gt; &lt;/template&gt; &lt;/a-table&gt; // script 部分 data()&#123; return &#123; columns:[ &#123; title: &#x27;用户账号&#x27;, dataIndex: &#x27;username&#x27;, &#125;, &#123; title: &#x27;姓名&#x27;, dataIndex: &#x27;name&#x27;, &#125;, &#123; title: &#x27;角色&#x27;, dataIndex: &#x27;duty&#x27;, scopedSlots: &#123;customRender: &#x27;duty&#x27;&#125; &#125;, &#123; title: &#x27;状态&#x27;, dataIndex: &#x27;status&#x27;, scopedSlots: &#123;customRender: &#x27;status&#x27;&#125; &#125;, &#123; title: &#x27;操作&#x27;, dataIndex: &#x27;action&#x27;, scopedSlots: &#123;customRender: &#x27;action&#x27;&#125;, &#125;], dataList: [], loading: false, &#125; &#125;, created()&#123; this.getList() &#125;, methods: &#123; getList()&#123; this.loading = true; this.$http.get(&#x27;/getUsers.do&#x27;).then(res =&gt; &#123; if(res)&#123; this.dataList = res || [] &#125; this.loading = false; &#125;).catch(err =&gt; &#123; console.log(err) &#125;) &#125;, editUser(record)&#123; this.$refs.addModal.showModal(record) &#125;, &#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 1.columns 定义table 表头,以及和 dataList 的字段对应,2. dataSource 为数据源,是一个数组,3.loading 加载时loading,数据请求前设置 true,请求完成后设置 false,4.插槽的使用很多情况下,后端返回的数据是 数字,前端需要展示文字,这事使用插槽就会非常方便1.首先,在 columns 中需要的部分添加 scopedSlots: {customRender: ‘status’}2.table 中添加标签 &lt;template slot=&quot;status&quot; slot-scope=&quot;text, record, index&quot;&gt; &lt;span v-if=&quot;text == &#x27;1&#x27;&quot;&gt;正常&lt;/span&gt; &lt;span v-if=&quot;text == &#x27;0&#x27;&quot;&gt;失效&lt;/span&gt;&lt;/template&gt;1234 customRender 的值和slot 的值相对应,slot-scope 中 text就是status的值(text可以自定义,key,item都可以), record 代表text所在的对象,可以通过 record 拿到该行的其他值. 比如 editUser(record)&#123; this.$refs.addModal.showModal(record)&#125;,123 把record作为参数传递,编辑改用户信息.","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://123wuyujuan.github.io/tags/JavaScript/"},{"name":"vue","slug":"vue","permalink":"https://123wuyujuan.github.io/tags/vue/"}]},{"title":"【解决方法】hexo g 报错 \"OperationalError:' EPERM:'  operation not permitted, unlink …\"","slug":"hexo-错误","date":"2020-10-19T08:10:50.000Z","updated":"2020-10-19T08:48:49.276Z","comments":true,"path":"uncategorized/hexo-错误/","link":"","permalink":"https://123wuyujuan.github.io/uncategorized/hexo-%E9%94%99%E8%AF%AF/","excerpt":"","text":"运行 hexo g 报错如下： FATAL &#123; err: [OperationalError: EPERM: operation not permitted, unlink &#39;F:\\blog\\public\\uncategorized\\newpaper&#39;] &#123; cause: [Error: EPERM: operation not permitted, unlink &#39;F:\\blog\\public\\uncategorized\\newpaper&#39;] &#123; errno: -4048, code: &#39;EPERM&#39;, syscall: &#39;unlink&#39;, path: &#39;F:\\\\blog\\\\public\\\\uncategorized\\\\newpaper&#39; &#125;, isOperational: true, errno: -4048, code: &#39;EPERM&#39;, syscall: &#39;unlink&#39;, path: &#39;F:\\\\blog\\\\public\\\\uncategorized\\\\newpaper&#39; &#125;&#125; 网上的解决办法： 权限不够，cmd 使用管理员打开无法解决 删除 C:\\Users\\用户 下 .npmrc 文件无法解决 清除缓存使用 npm clean cache --force 清除缓存 删除 package-lock.json 文件 使用 npm install 重新安装 无法解决 删除 node_modules 目录无法解决 解决方法 网上几乎全是针对 npm 的解决方法，而我的错误是在执行 hexo g 遇到的，且在官网上也没找到解决办法，最后尝试 删除 F:\\blog\\public\\ 下对应的目录 ，重新 hexo g 就不会报错了 他在错误中已经提示了： err: [OperationalError: EPERM: operation not permitted, unlink &#39;F:\\blog\\public\\uncategorized\\newpaper&#39;] 我一开始把 newpaper 文件删除了，但是他又会报另外 uncategorized 下的另一个文件的错，所以需要删除 uncategorized 整个目录，大家根据自己的情况删除就行了，我这个目录下的文件都是根据 source/_posts/ 生成的，删除之后再执行命令 hexo g 会重新生成的~","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://123wuyujuan.github.io/tags/hexo/"}]},{"title":"ES2020新特性","slug":"ES2020新特性","date":"2020-10-18T02:57:16.000Z","updated":"2020-10-19T03:44:12.283Z","comments":true,"path":"uncategorized/ES2020新特性/","link":"","permalink":"https://123wuyujuan.github.io/uncategorized/ES2020%E6%96%B0%E7%89%B9%E6%80%A7/","excerpt":"","text":"[TOC] Dynamic import不同于 ECMAScript2015 中的静态引入模块，Dynamic import 提供了按需引入、计算模块名称和脚本内部执行，并返回一个promise const modulePage = &#x27;page.js&#x27;;import(modulePage) .then((module) =&gt; &#123; module.default(); &#125;);(async () =&gt; &#123; const helpersModule = &#x27;helpers.js&#x27;; const module = await import(helpersModule) const total = module.sum(2, 2);&#125;)(); Promise.allSettled()在promise中有两个重要的方法：promise.all() 和 promise.race()，新增的 promise.allSettled() 方法，返回一个在所有给定的promise都已经fulfilled或rejected后的promise，并带有一个对象数组，每个对象表示对应的promise结果。 用法Promise.allSettled(iterable); 参数 iterable: 一个可迭代的对象，所有成员都是 promise 返回值 只要所有的 promise 都已经完成，无论是 resolve 还是 reject ，所有返回的 promise 都会集中为 一个数组， 数组包含每一个 promise 执行的结果。 每一个结果都是一个对象，包含一个 status 字符串，值为 fulfilled 或者 rejected，此外，还包含一个 fulfilled 时的 value或者 rejected 时的 reson。 const promise1 = Promise.resolve(3);const promise2 = new Promise((resolve, reject) =&gt; setTimeout(reject, 100, &#x27;foo&#x27;));const promises = [promise1, promise2];Promise.allSettled(promises). then((results) =&gt; results.forEach((result) =&gt; console.log(result))); // Object &#123; status: &quot;fulfilled&quot;, value: 3 &#125;// Object &#123; status: &quot;rejected&quot;, reason: &quot;foo&quot; &#125; 浏览器兼容性 String.prototype.matchAll(RegExp)以往，当我们使用 String.prototype.match() 方法时，总是返回一个数组，其中包含所有完全匹配的字符串： const text = &quot;From 2019.01.29 to 2019.01.30&quot;;const regexp = /(?&lt;year&gt;\\d&#123;4&#125;).(?&lt;month&gt;\\d&#123;2&#125;).(?&lt;day&gt;\\d&#123;2&#125;)/gu;const results = text.match(regexp);console.log(results);// [ &#x27;2019.01.29&#x27;, &#x27;2019.01.30&#x27; ] 而 matchAll() 还能够返回所有 Regex 捕获组： const text = &quot;From 2019.01.29 to 2019.01.30&quot;;const regexp = /(?&lt;year&gt;\\d&#123;4&#125;).(?&lt;month&gt;\\d&#123;2&#125;).(?&lt;day&gt;\\d&#123;2&#125;)/gu;const results = Array.from(text.matchAll(regexp));console.log(results);// [// [// &#x27;2019.01.29&#x27;,// &#x27;2019&#x27;,// &#x27;01&#x27;,// &#x27;29&#x27;,// index: 5,// input: &#x27;From 2019.01.29 to 2019.01.30&#x27;,// groups: [Object: null prototype] &#123; year: &#x27;2019&#x27;, month: &#x27;01&#x27;, day: &#x27;29&#x27; &#125;// ],// [// &#x27;2019.01.30&#x27;,// &#x27;2019&#x27;,// &#x27;01&#x27;,// &#x27;30&#x27;,// index: 19,// input: &#x27;From 2019.01.29 to 2019.01.30&#x27;,// groups: [Object: null prototype] &#123; year: &#x27;2019&#x27;, month: &#x27;01&#x27;, day: &#x27;30&#x27; &#125;// ]// ] 可选链操作符（?.）访问属性当要访问嵌套在对象内部的属性时，我们很有可能会遇到这样的错误： Uncaught TypeError: Cannot read property... 所以, 当我们需要访问一个属性时，我们经常会这样写以避免错误: let foo = obj &amp;&amp; obj.foo.// 确认 obj 和 obj.foo 都不是 undefined 或 null 但是即使是这样写也会经常遗漏，且繁琐，如果采用可选链式调用，就可以大量简化这样的前置校验： let foo = obj ?. foolet bar = obj ?. foo ?. bar 有了可选链操作符（?.），在访问 obj.foo.bar 之前，不再需要明确地校验 obj.foo 的状态，一旦遇到 null 或者 undefined就会返回 undefined。 访问方法当我们需要尝试调用一个可能不存在的方法时，可以使用可选链来避免返回异常： let result = obj.someMethod?.(); // ES2019的写法function doSomething(onContent, onError) &#123; try &#123; // ... do something with the data &#125; catch (err) &#123; if (onError) &#123; // 校验onError是否真的存在 onError(err.message); &#125; &#125;&#125;// 使用可选链进行函数调用function doSomething(onContent, onError) &#123; try &#123; // ... do something with the data &#125; catch (err) &#123; onError?.(err.message); // 如果onError是undefined也不会有异常 &#125;&#125; 可选链和表达式使用方括号和属性名的形式来访问属性： let foo = obj?.[&#x27;prop&#x27; + &#x27;Name&#x27;]; 访问数组元素： let item = arr ?. [20]; 可选链不能用于赋值let object = &#123;&#125;;object?.property = 1; // Uncaught SyntaxError: Invalid left-hand side in assignment 浏览器兼容性 空值合并操作符( ?? )通常，当我们需要为判断变量是否为 null ，并为变量赋值时，我们需要利用 逻辑或操作符(||)，当左边为假值时返回右侧操作数： let foo;// foo is never assigned any value so it is still undefinedlet someDummyText = foo || &#x27;Hello!&#x27;;// output: &#x27;Hello!&#x27; 看上去并没有什么问题，但 || 是一个布尔逻辑运算符，左侧的操作数会被强制转换为布尔值，因此，所有的假值（0, ‘’, NaN, null, undefined）都会被转为 false: let count = 0;let text = &quot;&quot;;let number = count || 42;let message = text || &quot;hi!&quot;;console.log(number); // 42，而不是 0console.log(message); // &quot;hi!&quot;，而不是 &quot;&quot; 而使用空值合并操作符可以避免，只有在第一个操作数为 null 或者 undefined 时，才返回第二个操作数： let count = 0;let text = &quot;&quot;;let number = count ?? 42;let message = text ?? &quot;hi!&quot;;console.log(number); // 0console.log(message); // “” 与可选链式操作符之间的关系空值合并操作符针对 undefined 与 null 这两个值，可选链式操作符（?.） 也是如此。在这访问属性可能为 undefined 与 null 的对象时，可选链式操作符非常有用。 let foo = &#123; someFooProp: &quot;hi&quot; &#125;;console.log(foo.someFooProp?.toUpperCase()); // &quot;HI&quot;console.log(foo.someBarProp?.toUpperCase()); // undefined","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://123wuyujuan.github.io/tags/JavaScript/"}]},{"title":"newpaper","slug":"newpaper","date":"2020-10-12T09:18:44.000Z","updated":"2020-10-19T10:29:32.983Z","comments":true,"path":"uncategorized/newpaper/","link":"","permalink":"https://123wuyujuan.github.io/uncategorized/newpaper/","excerpt":"","text":"my first blog!!I’m so excited!!!","categories":[],"tags":[{"name":"test","slug":"test","permalink":"https://123wuyujuan.github.io/tags/test/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-10-10T06:48:50.423Z","updated":"2020-10-19T08:10:17.328Z","comments":true,"path":"uncategorized/hello-world/","link":"","permalink":"https://123wuyujuan.github.io/uncategorized/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment good luck!","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://123wuyujuan.github.io/tags/JavaScript/"},{"name":"vue","slug":"vue","permalink":"https://123wuyujuan.github.io/tags/vue/"},{"name":"hexo","slug":"hexo","permalink":"https://123wuyujuan.github.io/tags/hexo/"},{"name":"test","slug":"test","permalink":"https://123wuyujuan.github.io/tags/test/"}]}