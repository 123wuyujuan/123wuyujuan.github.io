<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSRF攻击和防范</title>
    <url>/uncategorized/CSRF%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h1 id="CSRF-攻击方式"><a href="#CSRF-攻击方式" class="headerlink" title="CSRF 攻击方式"></a>CSRF 攻击方式</h1><p>CSRF 跨站请求伪造，通过诱导受害者进入第三方网站，在第三方网站中向被攻击网站发送跨站请求，利用受害者在被攻击网站已经获取的注册凭证，绕过后台用户验证，冒充用户操作。</p>
<p>一个典型的CSRF攻击有着如下的流程：</p>
<ul>
<li>受害者登录a.com，并保留了登录凭证（Cookie）</li>
<li>攻击者引诱受害者访问了b.com</li>
<li>b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带a.com的Cookie</li>
<li>a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求</li>
<li>a.com以受害者的名义执行了act=xx</li>
<li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作</li>
</ul>
<h1 id="防御方案"><a href="#防御方案" class="headerlink" title="防御方案"></a>防御方案</h1><p>CSRF 有三种防御方法：</p>
<ul>
<li>用户操作限制，验证码机制</li>
<li>请求来源限制：限制 HTTP Referer</li>
<li>Token 验证机制，请求数据字段中添加 token， 响应请求时校验其有效性</li>
</ul>
<p>对于第一种方案，影响用户体验，第二种方案成本低，但并不能保证 100% 安全， 第三种方案是目前最合适的方案。</p>
<h1 id="HTTP-Referer-防御机制"><a href="#HTTP-Referer-防御机制" class="headerlink" title="HTTP Referer 防御机制"></a>HTTP Referer 防御机制</h1><p><strong>在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。</strong>在通常情况下，访问一个安全受限页面的请求来自于同一个网站，如果黑客要对网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到正常网站时，该请求的 Referer 是指向黑客自己的网站。</p>
<p>因此，只需要对每一个请求验证其 Referer 值，如果 Referer 是来自其他网站的话，就说明可能遭到了 CSRF 攻击，拒绝请求。</p>
<h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p><strong>使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，</strong>然而，每个浏览器产商对于 Referer 的实现可能会有差别，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。</p>
<p>即使使用最新的浏览器，用户仍然可以设置浏览器使其在发送请求时不再提供 Referer。因为有些用户认为记录访问来源会侵犯他们的隐私。当他们正常访问网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。</p>
<h1 id="Token-验证机制防御"><a href="#Token-验证机制防御" class="headerlink" title="Token 验证机制防御"></a>Token 验证机制防御</h1><p>CSRF 攻击完全是因为黑客可以伪造用户的请求，请求中所有的用户验证信息全部存在 Cookie 中，黑客可以再不知道这些验证信息的情况下直接利用用户的 Cookie 通过验证。<strong>要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。</strong></p>
<h2 id="在-HTTP-头中加入自定义属性"><a href="#在-HTTP-头中加入自定义属性" class="headerlink" title="在 HTTP 头中加入自定义属性"></a>在 HTTP 头中加入自定义属性</h2><p>可以在 HTTP 请求中加入一个随机产生的 token，放到自定义的属性里，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p>
<ol>
<li>后端随机生成一个 Token 并保存在 Session 中，并把这个 Token 返回给前端</li>
<li>前端发起请求时把 Token 带到请求数据或者请求头中发送给后端</li>
<li>后端校验前端传入的 Token  和后端 Session 中的 Token 是否一致</li>
</ol>
<h2 id="NodeJS-下的-Token-验证"><a href="#NodeJS-下的-Token-验证" class="headerlink" title="NodeJS 下的 Token 验证"></a>NodeJS 下的 Token 验证</h2><p>NodeJS 不具备 Session 的功能，可以借助 Cookie 来传送 Token</p>
<ol>
<li>后端随机生成一个 Token，基于这个 Token 利用 SHA-56 等散列算法生成密文</li>
<li>后端将 Token 和生成的密文都设置为 Cookie，并返回给前端</li>
<li>前端发请求时，从 Cookie 中获取 Token，把 Token 加入请求数据或请求头</li>
<li>后端校验 Cookie 中的密文和前端请求带过来的 Token，进行正向散列验证</li>
</ol>
]]></content>
      <tags>
        <tag>web安全</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS攻击</title>
    <url>/uncategorized/DNS%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h3 id="DNS-request-Flood-攻击"><a href="#DNS-request-Flood-攻击" class="headerlink" title="DNS request Flood 攻击"></a>DNS request Flood 攻击</h3><h3 id="DNS-Reply-Flood-攻击"><a href="#DNS-Reply-Flood-攻击" class="headerlink" title="DNS Reply Flood 攻击"></a>DNS Reply Flood 攻击</h3><p>DNS 查询通常基于 UDP 协议，而 UDP 协议是无连接的，当 DNS 服务器收到 DNS reply报文时，不管自己有没有发出过解析请求，都会对 DNS reply 报文进行处理。DNS Reply Flood 就是黑客发送大量 DNS reply 报文给 DNS 服务器，导致消耗大量缓存服务器资源，无法正常解析 DNS 授权服务器发送的 DNS reply报文。</p>
<ul>
<li><h4 id="源认证"><a href="#源认证" class="headerlink" title="源认证"></a>源认证</h4><p>DNS Reply Flood 的源 IP 地址通常是伪造的，所以可以通过判断源 IP 地址的真假来防范攻击。这种方式通过构造一个 DNS request报文进行认证。</p>
<ul>
<li>DNS reply 报文超过阈值，收到 DNS reply 报文后会重新构造一个 DNS request 报文，并记录构造查询报文的Query ID和源端口号。</li>
<li>如果是真实源，则会回应 DNS reply 报文，如果与之前记录的 Query ID 和源端口号匹配成功，则加入白名单，认证成功。之后发送的报文直接通过。</li>
<li>如果是虚假源，则不会回应这个 DNS request 报文，认证不通过。</li>
</ul>
</li>
</ul>
<p><img src="https://forum.huawei.com/huaweiconnect/data/attachment/forum/201801/29/20180129110247726.png" alt="20180129110247726.png"></p>
<ul>
<li><p>DNS 反射攻击</p>
<p>一种更高级的 DNS Reply Flood，攻击目标是客户端而不是 DNS 缓存服务器，并且 DNS 请求是真实的</p>
<ul>
<li><h4 id="会话检查"><a href="#会话检查" class="headerlink" title="会话检查"></a>会话检查</h4><p>利用防火墙的会话表机制，DNS 交互过程中，DNS request 报文首包建立会话，保存五元组信息。当收到 DNS reply 报文时，匹配会话表，如果命中才允许通过。</p>
</li>
</ul>
</li>
</ul>
<h3 id="利用限速防范-DNS-Request-Flood-和-DNS-reply攻击"><a href="#利用限速防范-DNS-Request-Flood-和-DNS-reply攻击" class="headerlink" title="利用限速防范 DNS Request Flood 和 DNS reply攻击"></a>利用限速防范 DNS Request Flood 和 DNS reply攻击</h3><ul>
<li><p>域名限速</p>
<p>如果某个域名的DNS请求或回应报文速率过高，可以针对这个域名进行限速。</p>
</li>
<li><p>源 IP 地址限速</p>
<p>如果某个源IP地址域名解析的速率过大，就可以有针对性的对这个源IP地址进行限制，这样也不会对其他源有影响。</p>
</li>
</ul>
<h3 id="DNS-缓存投毒攻击"><a href="#DNS-缓存投毒攻击" class="headerlink" title="DNS 缓存投毒攻击"></a>DNS 缓存投毒攻击</h3>]]></content>
      <tags>
        <tag>DNS</tag>
        <tag>DDos</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>ES2020新特性</title>
    <url>/uncategorized/ES2020%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="Dynamic-import"><a href="#Dynamic-import" class="headerlink" title="Dynamic import"></a>Dynamic import</h3><p>不同于 <code>ECMAScript2015</code> 中的静态引入模块，<code>Dynamic import</code> 提供了<strong>按需引入</strong>、<strong>计算模块名称</strong>和<strong>脚本内部执行</strong>，并返回一个<code>promise</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> modulePage = <span class="string">&#x27;page.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span>(modulePage)</span><br><span class="line">    .then(<span class="function">(<span class="params"><span class="built_in">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">module</span>.default();</span><br><span class="line">    &#125;);</span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> helpersModule = <span class="string">&#x27;helpers.js&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">module</span> = <span class="keyword">await</span> <span class="keyword">import</span>(helpersModule)</span><br><span class="line">  <span class="keyword">const</span> total = <span class="built_in">module</span>.sum(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>



<h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled()"></a>Promise.allSettled()</h3><p>在<code>promise</code>中有两个重要的方法：<code>promise.all()</code> 和 <code>promise.race()</code>，新增的 <code>promise.allSettled()</code> 方法，返回一个在所有给定的promise都已经<code>fulfilled</code>或<code>rejected</code>后的promise，并带有一个对象数组，每个对象表示对应的promise结果。</p>
<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.allSettled(iterable);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>参数</p>
<p><code>iterable</code>: 一个可迭代的对象，所有成员都是 <code>promise</code></p>
</li>
<li><p>返回值</p>
<p>只要所有的 promise 都已经完成，无论是 resolve 还是 reject ，所有返回的 promise 都会集中为 一个数组， 数组包含每一个 promise 执行的结果。</p>
<p>每一个结果都是一个对象，包含一个 <code>status</code> 字符串，值为 <code>fulfilled</code> 或者 <code>rejected</code>，此外，还包含一个 fulfilled 时的 <code>value</code>或者 rejected 时的 <code>reson</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">100</span>, <span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line"><span class="keyword">const</span> promises = [promise1, promise2];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.allSettled(promises).</span><br><span class="line">  then(<span class="function">(<span class="params">results</span>) =&gt;</span> results.forEach(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">console</span>.log(result)));</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Object &#123; status: &quot;fulfilled&quot;, value: 3 &#125;</span></span><br><span class="line"><span class="comment">// Object &#123; status: &quot;rejected&quot;, reason: &quot;foo&quot; &#125;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h4><p><img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20201010112650897.png" alt="image-20201010112650897"></p>
<h3 id="String-prototype-matchAll-RegExp"><a href="#String-prototype-matchAll-RegExp" class="headerlink" title="String.prototype.matchAll(RegExp)"></a>String.prototype.matchAll(RegExp)</h3><p>以往，当我们使用 <code>String.prototype.match()</code> 方法时，总是返回一个数组，其中包含所有完全匹配的字符串：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="string">&quot;From 2019.01.29 to 2019.01.30&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> regexp = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;).(?&lt;month&gt;\d&#123;2&#125;).(?&lt;day&gt;\d&#123;2&#125;)/gu</span>;</span><br><span class="line"><span class="keyword">const</span> results = text.match(regexp);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(results);</span><br><span class="line"><span class="comment">// [ &#x27;2019.01.29&#x27;, &#x27;2019.01.30&#x27; ]</span></span><br></pre></td></tr></table></figure>

<p>而 <code>matchAll()</code> 还能够返回所有 <code>Regex</code> 捕获组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="string">&quot;From 2019.01.29 to 2019.01.30&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> regexp = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;).(?&lt;month&gt;\d&#123;2&#125;).(?&lt;day&gt;\d&#123;2&#125;)/gu</span>;</span><br><span class="line"><span class="keyword">const</span> results = <span class="built_in">Array</span>.from(text.matchAll(regexp));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(results);</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//   [</span></span><br><span class="line"><span class="comment">//     &#x27;2019.01.29&#x27;,</span></span><br><span class="line"><span class="comment">//     &#x27;2019&#x27;,</span></span><br><span class="line"><span class="comment">//     &#x27;01&#x27;,</span></span><br><span class="line"><span class="comment">//     &#x27;29&#x27;,</span></span><br><span class="line"><span class="comment">//     index: 5,</span></span><br><span class="line"><span class="comment">//     input: &#x27;From 2019.01.29 to 2019.01.30&#x27;,</span></span><br><span class="line"><span class="comment">//     groups: [Object: null prototype] &#123; year: &#x27;2019&#x27;, month: &#x27;01&#x27;, day: &#x27;29&#x27; &#125;</span></span><br><span class="line"><span class="comment">//   ],</span></span><br><span class="line"><span class="comment">//   [</span></span><br><span class="line"><span class="comment">//     &#x27;2019.01.30&#x27;,</span></span><br><span class="line"><span class="comment">//     &#x27;2019&#x27;,</span></span><br><span class="line"><span class="comment">//     &#x27;01&#x27;,</span></span><br><span class="line"><span class="comment">//     &#x27;30&#x27;,</span></span><br><span class="line"><span class="comment">//     index: 19,</span></span><br><span class="line"><span class="comment">//     input: &#x27;From 2019.01.29 to 2019.01.30&#x27;,</span></span><br><span class="line"><span class="comment">//     groups: [Object: null prototype] &#123; year: &#x27;2019&#x27;, month: &#x27;01&#x27;, day: &#x27;30&#x27; &#125;</span></span><br><span class="line"><span class="comment">//   ]</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure>

<h3 id="可选链操作符（-）"><a href="#可选链操作符（-）" class="headerlink" title="可选链操作符（?.）"></a>可选链操作符（?.）</h3><h4 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h4><p>当要访问嵌套在<strong>对象内部的属性</strong>时，我们很有可能会遇到这样的错误：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Uncaught <span class="built_in">TypeError</span>: Cannot read property...</span><br></pre></td></tr></table></figure>

<p>所以, 当我们需要访问一个属性时，我们经常会这样写以避免错误:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = obj &amp;&amp; obj.foo.<span class="comment">// 确认 obj 和 obj.foo 都不是 undefined 或 null</span></span><br></pre></td></tr></table></figure>

<p>但是即使是这样写也会经常遗漏，且繁琐，如果采用可选链式调用，就可以大量简化这样的前置校验：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = obj ?. foo</span><br><span class="line"><span class="keyword">let</span> bar = obj ?. foo ?. bar</span><br></pre></td></tr></table></figure>

<p>有了可选链操作符（<code>?.</code>），在访问 <code>obj.foo.bar</code> 之前，不再需要明确地校验 <code>obj.foo</code> 的状态，一旦遇到 <code>null</code> 或者 <code>undefined</code>就会返回 <code>undefined</code>。</p>
<h4 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h4><p>当我们需要<strong>尝试调用一个可能不存在的方法</strong>时，可以使用可选链来避免返回异常：</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = obj.someMethod?.();</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  ES2019的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">onContent, onError</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ... do something with the data </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (onError) &#123; <span class="comment">// 校验onError是否真的存在</span></span><br><span class="line">      onError(err.message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用可选链进行函数调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">onContent, onError</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// ... do something with the data</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    onError?.(err.message); <span class="comment">// 如果onError是undefined也不会有异常</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="可选链和表达式"><a href="#可选链和表达式" class="headerlink" title="可选链和表达式"></a>可选链和表达式</h4><p>使用方括号和属性名的形式来访问属性：</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = obj?.[<span class="string">&#x27;prop&#x27;</span> + <span class="string">&#x27;Name&#x27;</span>];</span><br></pre></td></tr></table></figure>
</blockquote>
<p>访问数组元素：</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> item = arr ?. [<span class="number">20</span>];</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="可选链不能用于赋值"><a href="#可选链不能用于赋值" class="headerlink" title="可选链不能用于赋值"></a>可选链不能用于赋值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> object = &#123;&#125;;</span><br><span class="line">object?.property = <span class="number">1</span>; <span class="comment">// Uncaught SyntaxError: Invalid left-hand side in assignment</span></span><br></pre></td></tr></table></figure>

<h4 id="浏览器兼容性-1"><a href="#浏览器兼容性-1" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h4><p><img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20201009183538356.png" alt="image-20201009183538356"></p>
<h3 id="空值合并操作符"><a href="#空值合并操作符" class="headerlink" title="空值合并操作符( ?? )"></a>空值合并操作符( ?? )</h3><p>通常，当我们需要为判断变量是否为 <strong>null</strong> ，并为变量赋值时，我们需要利用 <code>逻辑或操作符(||)</code>，当左边为假值时返回右侧操作数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo;</span><br><span class="line"><span class="comment">//  foo is never assigned any value so it is still undefined</span></span><br><span class="line"><span class="keyword">let</span> someDummyText = foo || <span class="string">&#x27;Hello!&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output: &#x27;Hello!&#x27;</span></span><br></pre></td></tr></table></figure>

<p>看上去并没有什么问题，但 <code>||</code> 是一个布尔逻辑运算符，左侧的操作数会被强制转换为布尔值，因此，所有的假值（<code>0</code>, <code>‘’,</code> <code>NaN</code>, <code>null</code>, <code>undefined</code>）都会被转为 <code>false</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> number = count || <span class="number">42</span>;</span><br><span class="line"><span class="keyword">let</span> message = text || <span class="string">&quot;hi!&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(number);     <span class="comment">// 42，而不是 0</span></span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// &quot;hi!&quot;，而不是 &quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>而使用空值合并操作符可以避免，只有在第一个操作数为 <code>null</code> 或者 <code>undefined</code> 时，才返回第二个操作数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> number = count ?? <span class="number">42</span>;</span><br><span class="line"><span class="keyword">let</span> message = text ?? <span class="string">&quot;hi!&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(number);     <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// “”</span></span><br></pre></td></tr></table></figure>

<h4 id="与可选链式操作符之间的关系"><a href="#与可选链式操作符之间的关系" class="headerlink" title="与可选链式操作符之间的关系"></a>与可选链式操作符之间的关系</h4><p>空值合并操作符针对 <code>undefined</code> 与 <code>null</code> 这两个值，可选链式操作符（<code>?.</code>） 也是如此。在这访问属性可能为 <code>undefined</code> 与 <code>null</code> 的对象时，可选链式操作符非常有用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123; <span class="attr">someFooProp</span>: <span class="string">&quot;hi&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.someFooProp?.toUpperCase()); <span class="comment">// &quot;HI&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.someBarProp?.toUpperCase()); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 常用命令和问题</title>
    <url>/uncategorized/Git%20%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E5%92%8C%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>文章记录自己对 Git 操作的理解，和一些在使用过程中遇到的问题和解决方法，不定时更新</p>
<hr>
<h2 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h2><ul>
<li><p><strong>查看分支</strong></p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>创建分支</strong></p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b newbranch</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>切换分支</strong></p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout newbranch</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>添加到暂存区</strong></p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add &lt;file&gt;</span><br><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p>这两个一个是添加单个文件，一个是添加所有改动的文件，如果改动的文件多，可以先使用第二个命令添加所有文件，然后再 使用 <code>git restore &lt;file&gt;</code> 将不需要提交修改的文件移出来。</p>
</blockquote>
</li>
<li><p><strong>提交代码</strong></p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;feat: xxx&quot;</span><br></pre></td></tr></table></figure>

<p>新功能可以用feat，对原来代码的修改可以用 fix，具体的规范可以参照</p>
</blockquote>
</li>
<li><p><strong>本地合并代码</strong></p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout newbranch</span><br><span class="line">git merge origin&#x2F;develop</span><br></pre></td></tr></table></figure>

<p>这两个命令将本地的 develop 分支代码合并到 newbranch 分支</p>
</blockquote>
</li>
<li><p><strong>删除本地分支</strong></p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -d &lt;name&gt;</span><br></pre></td></tr></table></figure>

<p>强制删除：<code>git branch -D &lt;name&gt;</code></p>
</blockquote>
</li>
<li><p><strong>删除远端分支</strong></p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -a 查看远端和本地的所有分支</span><br><span class="line">git push origin :远端分支 push一个空的到远端分支，注意origin 后面的空格</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h2 id="git-准备开发的流程"><a href="#git-准备开发的流程" class="headerlink" title="git 准备开发的流程"></a>git 准备开发的流程</h2><ol>
<li><p>本地切换到 develop 分支，将远程 develop 分支拉到本地，合并 （*develop)</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull origin develop</span><br></pre></td></tr></table></figure>

<p>合并如果有冲突，<code>git status</code>、 <code>git diff</code> 看是哪些文件有冲突，到文件里解决冲突，再<code>git reset --merge</code></p>
</blockquote>
</li>
<li><p>在 develop 上分出一个开发分支 <code>xxx</code>  (*develop)</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b xxx</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>切换到 xxx 分支进行开发 (*xxx)</p>
</li>
</ol>
<h2 id="开发完毕提交操作"><a href="#开发完毕提交操作" class="headerlink" title="开发完毕提交操作"></a>开发完毕提交操作</h2><ol>
<li><p>切换到 develop 分支，如果提示没有 commit 或者 stash 就 stash</p>
</li>
<li><p>在 develop 分支上拉取远端最新的代码</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull origin develop</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>切换到开发分支 <code>xxx</code>，将 develop 分支里最新的代码合并到开发分支</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout xxx</span><br><span class="line">git merge origin&#x2F;develop</span><br></pre></td></tr></table></figure>

<p>如果有冲突，解决冲突重新合并</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --merge</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>提交开发分支中的改动</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add &lt;file&gt;</span><br><span class="line">git commit -m &quot;feat: xxx&quot;</span><br></pre></td></tr></table></figure>

<p><strong>在开发分支中 git log 时有之前的提交记录是正常的，提交到远端的新分支之后有之前的提交记录也是正常的，不要慌。</strong>创建 MergeRequest 的时候就只有这一次推送的提交了</p>
<p>如果add错了一个文件，<code>git restore --staged</code> 可以撤销这个文件的</p>
</blockquote>
</li>
<li><p>推送到远端</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin xxx:yyy</span><br></pre></td></tr></table></figure>

<p>使用这个命令后，会将本地的 xxx 分支推送远端自动新建的 yyy 分支</p>
<p>推送的是距离你从本次开发开始的提交记录，比如从远端拉下来合并之后有了commit1, commit2, commit3 这几个提交记录，本次开发过程中提交了两次：commit4 和 commit5，那么推送的也就是这两个记录，在创建 Merge Request 的时候 commits 也是 2</p>
</blockquote>
</li>
<li><p>创建 Issue 和 MergeRequest</p>
<p>Issue 可以不在这个时候创建，开发功能之前就可以创建了，意味着自己要开发新功能了</p>
<p>MergeRequest 就是合并请求，我这里是新功能分支 合并到 develop 分支，merge 之后自动删除 userperm 分支。具体的看公司要求。</p>
<p><img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20201106094925485.png" alt="image-20201106094925485"></p>
</li>
</ol>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a><strong>Q&amp;A</strong></h2><h3 id="已经-commit-但没有push-，想要撤销本次提交，但要保留代码修改？"><a href="#已经-commit-但没有push-，想要撤销本次提交，但要保留代码修改？" class="headerlink" title="已经 commit 但没有push ，想要撤销本次提交，但要保留代码修改？"></a><strong>已经 commit 但没有push ，想要撤销本次提交，但要保留代码修改？</strong></h3><blockquote>
<p>使用 <code>git log</code> 打印提交记录，看到如下提交信息</p>
</blockquote>
<p><img src="http://qjd5jli58.hn-bkt.clouddn.com/img/image-20201106095904118.jpg" alt="image-20201106095904118"></p>
<blockquote>
<p>现在，我们想要撤销第一个和第二个提交记录，但又不想代码也跟着回滚，于是，我们可以用<code>git reset --soft HEAD^</code> 命令来撤销第一个提交，也就是<code>bcee1b</code> 的提交，然后再用一次 <code>git reset --soft HEAD^</code> 就成功撤销这两个记录了。</p>
</blockquote>
<p>你也可以使用<code>git reset --soft HEAD~2</code> 来一次性撤销两个提交记录，现在，我们使用 <code>git log</code> 查看提交记录：</p>
<p>可以看到已经撤销了两次提交。</p>
<p><strong>使用这个命令，git add 操作不会被撤销</strong>，使用 <code>git status</code> 查看状态，之前 add 的记录还在：</p>
<p>![image][2]</p>
<p><img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20201106101956645.png" alt="image-20201106101956645"></p>
<h3 id="撤销提交记录的同时不保留代码修改怎么做？"><a href="#撤销提交记录的同时不保留代码修改怎么做？" class="headerlink" title="撤销提交记录的同时不保留代码修改怎么做？"></a>撤销提交记录的同时不保留代码修改怎么做？</h3><p>使用 <code>git reset --hard HEAD^</code> 就可以办到。这个命令会删除改动的代码，撤销 commit 和 add，恢复到上一次的 commit 状态。</p>
<h3 id="恢复到上一次提交记录之后又后悔了怎么办？"><a href="#恢复到上一次提交记录之后又后悔了怎么办？" class="headerlink" title="恢复到上一次提交记录之后又后悔了怎么办？"></a>恢复到上一次提交记录之后又后悔了怎么办？</h3><p>刚刚使用了 <code>git reset --hard HEAD^</code> 命令恢复了上一次的 commit 状态，同时代码也没有被保存，如果后悔了，可以使用 <code>git reflog</code> 命令查看之前所有的提交记录和操作记录，找到需要恢复的那个版本，复制前面的 commitID，例如我们想要回到bcee1b4 这个版本：</p>
<p>![image][3]</p>
<p><img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20201106102813045.png"></p>
<p>使用命令，然后查看 提交记录：</p>
<p>![image][4]</p>
<p><img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20201106103257356.png" alt="image-20201106103257356"></p>
<p>又回来了。</p>
<h3 id="在-commit-的时候写错注释了怎么办？"><a href="#在-commit-的时候写错注释了怎么办？" class="headerlink" title="在 commit 的时候写错注释了怎么办？"></a>在 commit 的时候写错注释了怎么办？</h3><blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>

<p>这个命令会默认进入 vim 编辑器，修改好注释之后保存就可以了。</p>
</blockquote>
<h3 id="已经-push-到远端还没合并，需要修改代码"><a href="#已经-push-到远端还没合并，需要修改代码" class="headerlink" title="已经 push 到远端还没合并，需要修改代码"></a>已经 push 到远端还没合并，需要修改代码</h3><p>如果已经将本地的开发分支 push 到远端，但是这个时候不管出于什么原因需要修改代码，但是修改好了之后提交到远端，发起 MergeRequest 的时候是没有原来的提交记录的。比如我第一次 push 的时候有 commit-1 的记录，现在在本地改了代码，有了 commit-2 的记录，然后 push 到了一个新的远端分支 zzz ，在这个新的分支上再建一个 Merge Request，那么这个 MergeRequest 里面就只有一个 commit。</p>
<p>可以参考第一个问题，在本地撤销前面的 commit 但保留更改，然后重新提交，这样下一次提交就包含了两次的修改。</p>
<p>或者也可以在修改代码之后 push 到远端上一次push 的 yyy 分支上，这样远端就有了两个 commit ，看自己的需求。</p>
<h3 id="如何同步远程已删除的分支"><a href="#如何同步远程已删除的分支" class="headerlink" title="如何同步远程已删除的分支"></a>如何同步远程已删除的分支</h3><h4 id="删除远端多余分支"><a href="#删除远端多余分支" class="headerlink" title="删除远端多余分支"></a>删除远端多余分支</h4><blockquote>
<p>使用 <code>git branch -a</code> 命令查看本地和远程的所有分支，红色部分就是远端分支</p>
</blockquote>
<p><img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20201106111008267.png" alt="image-20201106111008267"></p>
<p>可以看到，有的远端分支明明已经删除了，但本地并没有同步过来。</p>
<blockquote>
<p>使用 <code>git remote show origin</code> 命令查看本地分支和远端分支的追踪情况</p>
</blockquote>
<p><img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20201106111605075.png"></p>
<p>根据提示，可以使用 <code>git remote prune</code> 命令来同步删除这些分支。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote prune</span><br></pre></td></tr></table></figure>

<p>再次查看就已经删除这些多余的分支了image-20201106111856467](C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20201106111856467.png)</p>
<h4 id="删除本地多余分支"><a href="#删除本地多余分支" class="headerlink" title="删除本地多余分支"></a>删除本地多余分支</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -D feature&#x2F;chatfix</span><br></pre></td></tr></table></figure>

<p>[]: </p>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>用HTML和JavaScript模拟XSS攻击</title>
    <url>/uncategorized/XSS%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<p>HTML文件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;input&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;onSubmit(input.value)&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- &lt;script src=&quot;./xss.js&quot;&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="javascript">	<span class="function"><span class="keyword">function</span> <span class="title">onSubmit</span>(<span class="params">value</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">		<span class="built_in">document</span>.write(value)</span></span><br><span class="line"><span class="javascript">		<span class="built_in">console</span>.log(value)</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在网页中的 input 框输入普通字符串：</p>
<p><img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20201029175836887.png" alt="image-20201029175836887"></p>
<p>网页上显示正常字符串 123 </p>
<p>接着输入 JavaScript 代码：<code>&lt;script&gt;alert(&#39;XSS攻击&#39;)&lt;/script&gt;</code></p>
<p><img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20201029180138872.png" alt="image-20201029180138872"></p>
<p>提交之后显示：</p>
<p><img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20201029180209237.png" alt="image-20201029180209237"></p>
<p>打开调试页面：</p>
<p><img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20201029180342204.png" alt="image-20201029180342204"></p>
<p>甚至可以从远端加载 JavaScript 文件进行攻击，我这里加载的是同级目录下的 xss.js 文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// xss.js</span></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">5</span></span><br><span class="line"><span class="function"><span class="title">while</span>(<span class="params">i &gt; <span class="number">1</span></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">&#x27;反射型XSS攻击&#x27;</span>)</span><br><span class="line">	i--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入框中输入 <code>&lt;script src=&quot;./xss.js&quot;&gt;&lt;/script&gt;</code>，提交后会显示4次警告框：</p>
<p><img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20201029180755869.png" alt="image-20201029180755869"></p>
<h4 id="XSS-注入的方法"><a href="#XSS-注入的方法" class="headerlink" title="XSS 注入的方法"></a><strong>XSS 注入的方法</strong></h4><ul>
<li>HTML 内嵌文本中，以 script 标签注入代码</li>
<li>在内联 JavaScript 中，拼接的数据突破了原本的限制</li>
<li>在标签属性中，恶意内容包含引号，突破属性值的限制，注入其他属性或标签</li>
<li>在标签的 href 、src 属性中，包含 <code>javascript:</code>可执行代码</li>
<li>在 <code>onload</code> <code>onerror</code> <code>onclick</code>等事件中，注入不受控制的代码</li>
<li><code>background-image:url(&quot;javascript:...&quot;);</code> 的代码（新版本浏览器已经可以防范）</li>
<li>在 style 属性和标签中，包含类似 <code>expression(...)</code> 的 CSS 表达式代码（新版本浏览器已经可以防范）</li>
</ul>
<h4 id="XSS-攻击分类"><a href="#XSS-攻击分类" class="headerlink" title="XSS 攻击分类"></a>XSS 攻击分类</h4><ul>
<li><p>存储型</p>
<p>攻击步骤：</p>
<ol>
<li>攻击者将恶意代码<strong>提交到目标网站的数据库</strong>中。</li>
<li><strong>用户打开目标网站时，网站服务端将恶意代码从数据库取出</strong>，拼接在 HTML 中返回给浏览器。</li>
<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>
</ol>
<p><strong>常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等</strong></p>
</li>
<li><p>反射型</p>
<p>攻击步骤：</p>
<ol>
<li>攻击者构造出特殊的 URL，其中包含恶意代码。</li>
<li><strong>用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出</strong>，拼接在 HTML 中返回给浏览器。</li>
<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li>
</ol>
<p><strong>常见于通过 URL 传递参数的功能，如网站搜索、跳转等</strong></p>
</li>
<li><p>DOM 型</p>
<p>攻击步骤：</p>
<ol>
<li><p>攻击者构造出特殊的 URL，其中包含恶意代码。</p>
</li>
<li><p>用户打开带有恶意代码的 URL。</p>
</li>
<li><p><strong>用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行</strong>。</p>
</li>
<li><p>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</p>
</li>
</ol>
</li>
</ul>
<p>  <strong>DOM 型 XSS 跟前两种 XSS 的区别：</strong>DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。</p>
<h4 id="XSS-攻击防范"><a href="#XSS-攻击防范" class="headerlink" title="XSS 攻击防范"></a><strong>XSS 攻击防范</strong></h4><p>XSS 攻击的本质是：恶意代码未经过滤，与正常的代码混在一起被执行，由于直接在终端执行，所以能够直接获取用户信息，或者利用这些信息冒充用户发起请求</p>
<p>来源：</p>
<ul>
<li><strong>来自用户的 UGC 信息</strong></li>
<li><strong>来自第三方的链接</strong></li>
<li><strong>URL 参数</strong></li>
<li><strong>POST 参数</strong></li>
<li><strong>Referer （可能来自不可信的来源）</strong></li>
<li><strong>Cookie （可能来自其他子域注入）</strong></li>
</ul>
<p>大致过程为：攻击者提交恶意代码，浏览器执行恶意代码</p>
<h5 id="前端过滤用户输入"><a href="#前端过滤用户输入" class="headerlink" title="前端过滤用户输入"></a>前端过滤用户输入</h5><p>一旦绕过前端过滤，直接构造请求，就无法防范</p>
<h5 id="后端过滤用户输入"><a href="#后端过滤用户输入" class="headerlink" title="后端过滤用户输入"></a>后端过滤用户输入</h5><ol>
<li><p>用户的输入内容可能同时提供给前端和客户端，而一旦经过了 <code>escapeHTML()</code>，客户端显示的内容就变成了乱码( <code>5 &lt; 7</code> )。</p>
</li>
<li><p>在前端中，不同的位置所需的编码也不同。</p>
<ul>
<li>当 <code>5 &lt; 7</code> 作为 HTML 拼接页面时，可以正常显示：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">title</span>=<span class="string">&quot;comment&quot;</span>&gt;</span>5 <span class="symbol">&amp;lt;</span> 7<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当 <code>5 &lt; 7</code> 通过 Ajax 返回，然后赋值给 JavaScript 的变量时，前端得到的字符串就是转义后的字符。这个内容不能直接用于 Vue 等模板的展示，也不能直接用于内容长度计算。不能用于标题、alert 等。</li>
</ul>
</li>
</ol>
<p>所以，输入侧过滤能够在某些情况下解决特定的 XSS 问题，但会引入很大的不确定性和乱码问题。在防范 XSS 攻击时应避免此类方法。但对于数字、url、电话邮件地址等可以进行过滤。</p>
<h5 id="防止浏览器执行恶意代码"><a href="#防止浏览器执行恶意代码" class="headerlink" title="防止浏览器执行恶意代码"></a>防止浏览器执行恶意代码</h5><p><strong>存储型和反射型 XSS 攻击</strong></p>
<ul>
<li><p>纯前端渲染</p>
<p>明确告诉浏览器下面的内容是文本（<code>.innerText</code>），还是属性（<code>.setAttribute</code>），样式（<code>.style</code>）</p>
<p>无法预防 DOM 型 XSS 漏洞 （<code>onload</code> 、<code>onerror</code> 、<code>href:javascript:xxx</code>）</p>
</li>
<li><p>HTML 转义</p>
<p> 采用转移策略，对特殊字符进行转义。转义库：<code>org.owasp.encoder</code></p>
</li>
</ul>
<p><strong>DOM 型 XSS 攻击</strong></p>
<p>小心使用<code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code>，尽量用 <code>.textContent</code>、<code>setAttribute()</code>。</p>
<ul>
<li>如果用 Vue/React 技术栈，并且不使用 <code>v-html</code>/<code>dangerouslySetInnerHTML</code> 功能，就在前端 render 阶段避免 <code>innerHTML</code>、<code>outerHTML</code> 的 XSS 隐患</li>
</ul>
<h4 id="其他防范方法"><a href="#其他防范方法" class="headerlink" title="其他防范方法"></a>其他防范方法</h4><h5 id="Content-Security-Policy"><a href="#Content-Security-Policy" class="headerlink" title="Content Security Policy"></a><strong>Content Security Policy</strong></h5><p>严格的 CSP 在 XSS 的防范中可以起到以下的作用：</p>
<ul>
<li>禁止加载外域代码，防止复杂的攻击逻辑。</li>
<li>禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。</li>
<li>禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。</li>
<li>禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。</li>
<li>合理使用上报可以及时发现 XSS，利于尽快修复问题。</li>
</ul>
<h5 id="输入内容长度控制"><a href="#输入内容长度控制" class="headerlink" title="输入内容长度控制"></a>输入内容长度控制</h5><p>对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度。</p>
<h5 id="HTTP-only-Cookie"><a href="#HTTP-only-Cookie" class="headerlink" title="HTTP-only Cookie"></a>HTTP-only Cookie</h5><p>禁止 JavaScript 读取敏感 Cookie，让攻击者注入后无法取得 Cookie。</p>
<h5 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h5><p>防止脚本冒充用户。</p>
<h4 id="XSS-漏洞检测"><a href="#XSS-漏洞检测" class="headerlink" title="XSS 漏洞检测"></a>XSS 漏洞检测</h4><ul>
<li><p>手动检测</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">jaVasCript:/*-/*`/*\`/*&#x27;/*&quot;/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//&lt;/stYle/&lt;/titLe/&lt;/teXtarEa/&lt;/scRipt/--!&gt;\x3csVg/&lt;sVg/oNloAd=alert()//&gt;\x3e</span><br></pre></td></tr></table></figure>

<p>在输入框中提交或者拼接到 url 参数上进行检测</p>
</li>
<li><p>自动扫描</p>
<ul>
<li><a href="https://github.com/Arachni/arachni">Arachni</a>、<a href="https://github.com/mozilla/http-observatory/">Mozilla HTTP Observatory</a>、<a href="https://github.com/andresriancho/w3af">w3af</a> </li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>ant-design-vue 插槽使用</title>
    <url>/uncategorized/ant-design%20vue%20%E6%8F%92%E6%A7%BD%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a-table</span> <span class="attr">:columns</span>=<span class="string">&quot;columns&quot;</span> <span class="attr">:dataSource</span>=<span class="string">&quot;dataList&quot;</span> <span class="attr">:loading</span>=<span class="string">&quot;loading&quot;</span> <span class="attr">:pagination</span>=<span class="string">&quot;false&quot;</span> <span class="attr">:rowKey</span>=<span class="string">&quot;(record,index) =&gt; index&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">&quot;duty&quot;</span> <span class="attr">slot-scope</span>=<span class="string">&quot;text, record, index&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;text == &#x27;general&#x27;&quot;</span>&gt;</span>普通员工<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;text == &#x27;expert&#x27;&quot;</span>&gt;</span>专家<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;text == &#x27;admin&#x27;&quot;</span>&gt;</span>管理员<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">&quot;status&quot;</span> <span class="attr">slot-scope</span>=<span class="string">&quot;text, record, index&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;text == &#x27;1&#x27;&quot;</span>&gt;</span>正常<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;text == &#x27;0&#x27;&quot;</span>&gt;</span>失效<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">&quot;action&quot;</span> <span class="attr">slot-scope</span>=<span class="string">&quot;text, record, index&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">size</span>=<span class="string">&quot;small&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;editUser(record)&quot;</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">a-button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">a-table</span>&gt;</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// script 部分</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            columns:[</span><br><span class="line">       &#123;</span><br><span class="line">           title: <span class="string">&#x27;用户账号&#x27;</span>,</span><br><span class="line">           dataIndex: <span class="string">&#x27;username&#x27;</span>,</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">           title: <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">           dataIndex: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">           title: <span class="string">&#x27;角色&#x27;</span>,</span><br><span class="line">           dataIndex: <span class="string">&#x27;duty&#x27;</span>,</span><br><span class="line">           scopedSlots: &#123;<span class="attr">customRender</span>: <span class="string">&#x27;duty&#x27;</span>&#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">           title: <span class="string">&#x27;状态&#x27;</span>,</span><br><span class="line">           dataIndex: <span class="string">&#x27;status&#x27;</span>,</span><br><span class="line">           scopedSlots: &#123;<span class="attr">customRender</span>: <span class="string">&#x27;status&#x27;</span>&#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">           title: <span class="string">&#x27;操作&#x27;</span>,</span><br><span class="line">           dataIndex: <span class="string">&#x27;action&#x27;</span>,</span><br><span class="line">           scopedSlots: &#123;<span class="attr">customRender</span>: <span class="string">&#x27;action&#x27;</span>&#125;,</span><br><span class="line">       &#125;],</span><br><span class="line">            dataList: [],</span><br><span class="line">            loading: <span class="literal">false</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">created</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.getList()</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">     <span class="function"><span class="title">getList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.loading = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.$http.get(<span class="string">&#x27;/getUsers.do&#x27;</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="function"><span class="title">if</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">                    <span class="built_in">this</span>.dataList = res || []</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">this</span>.loading = <span class="literal">false</span>;</span><br><span class="line">            &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(err)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">editUser</span>(<span class="params">record</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.$refs.addModal.showModal(record)</span><br><span class="line">        &#125;,</span><br><span class="line">  	&#125;</span><br></pre></td></tr></table></figure>



<h5 id="1-columns-定义table-表头-以及和-dataList-的字段对应"><a href="#1-columns-定义table-表头-以及和-dataList-的字段对应" class="headerlink" title="1.columns 定义table 表头,以及和 dataList 的字段对应,"></a>1.columns 定义table 表头,以及和 dataList 的字段对应,</h5><h5 id="2-dataSource-为数据源-是一个数组"><a href="#2-dataSource-为数据源-是一个数组" class="headerlink" title="2. dataSource 为数据源,是一个数组,"></a>2. dataSource 为数据源,是一个数组,</h5><h5 id="3-loading-加载时loading-数据请求前设置-true-请求完成后设置-false"><a href="#3-loading-加载时loading-数据请求前设置-true-请求完成后设置-false" class="headerlink" title="3.loading 加载时loading,数据请求前设置 true,请求完成后设置 false,"></a>3.loading 加载时loading,数据请求前设置 true,请求完成后设置 false,</h5><h5 id="4-插槽的使用"><a href="#4-插槽的使用" class="headerlink" title="4.插槽的使用"></a>4.插槽的使用</h5><p>很多情况下,后端返回的数据是 数字,前端需要展示文字,这事使用插槽就会非常方便<br>1.首先,在 columns 中需要的部分添加 scopedSlots: {customRender: ‘status’}<br>2.table 中添加标签</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template slot=<span class="string">&quot;status&quot;</span> slot-scope=<span class="string">&quot;text, record, index&quot;</span>&gt;</span><br><span class="line">   &lt;span v-<span class="keyword">if</span>=<span class="string">&quot;text == &#x27;1&#x27;&quot;</span>&gt;正常&lt;/span&gt;</span><br><span class="line">    &lt;span v-<span class="keyword">if</span>=<span class="string">&quot;text == &#x27;0&#x27;&quot;</span>&gt;失效&lt;/span&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>customRender 的值和slot 的值相对应,slot-scope 中 text就是status的值(text可以自定义,key,item都可以), record 代表text所在的对象,可以通过 record 拿到该行的其他值. 比如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">editUser</span>(<span class="params">record</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.$refs.addModal.showModal(record)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>把record作为参数传递,编辑改用户信息.</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/uncategorized/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<p>good luck!</p>
]]></content>
  </entry>
  <entry>
    <title>【解决方法】hexo g 报错 &quot;OperationalError:&#39; EPERM:&#39;  operation not permitted, unlink …&quot;</title>
    <url>/uncategorized/hexo-%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>运行 hexo g 报错如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FATAL &#123;</span><br><span class="line">  err: [OperationalError: EPERM: operation not permitted, unlink &#39;F:\blog\public\uncategorized\newpaper&#39;] &#123;</span><br><span class="line">    cause: [Error: EPERM: operation not permitted, unlink &#39;F:\blog\public\uncategorized\newpaper&#39;] &#123;</span><br><span class="line">      errno: -4048,</span><br><span class="line">      code: &#39;EPERM&#39;,</span><br><span class="line">      syscall: &#39;unlink&#39;,</span><br><span class="line">      path: &#39;F:\\blog\\public\\uncategorized\\newpaper&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    isOperational: true,</span><br><span class="line">    errno: -4048,</span><br><span class="line">    code: &#39;EPERM&#39;,</span><br><span class="line">    syscall: &#39;unlink&#39;,</span><br><span class="line">    path: &#39;F:\\blog\\public\\uncategorized\\newpaper&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>网上的解决办法：</p>
<ol>
<li><h4 id="权限不够，cmd-使用管理员打开"><a href="#权限不够，cmd-使用管理员打开" class="headerlink" title="权限不够，cmd 使用管理员打开"></a>权限不够，cmd 使用管理员打开</h4><p>无法解决</p>
</li>
<li><h4 id="删除-C-Users-用户-下-npmrc-文件"><a href="#删除-C-Users-用户-下-npmrc-文件" class="headerlink" title="删除 C:\Users\用户 下 .npmrc 文件"></a>删除 <code>C:\Users\用户</code> 下 <code>.npmrc</code> 文件</h4><p><strong>无法解决</strong></p>
</li>
<li><h4 id="清除缓存"><a href="#清除缓存" class="headerlink" title="清除缓存"></a>清除缓存</h4><p>使用 <code>npm clean cache --force</code> 清除缓存</p>
<p>删除 <code>package-lock.json</code> 文件</p>
<p>使用 <code>npm install</code> 重新安装</p>
<p><strong>无法解决</strong></p>
</li>
<li><h4 id="删除-node-modules-目录"><a href="#删除-node-modules-目录" class="headerlink" title="删除 node_modules 目录"></a>删除<code> node_modules</code> 目录</h4><p><strong>无法解决</strong></p>
</li>
</ol>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>   网上几乎全是针对 npm 的解决方法，而我的错误是在执行 <code>hexo g</code>  遇到的，且在官网上也没找到解决办法，最后尝试 <strong>删除 F:\blog\public\ 下对应的目录</strong> ，重新 <code>hexo g</code> 就不会报错了</p>
<p>   他在错误中已经提示了：</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">err: [OperationalError: EPERM: operation not permitted, unlink &#39;F:\blog\public\uncategorized\newpaper&#39;]</span><br></pre></td></tr></table></figure>



<p>   我一开始把 newpaper 文件删除了，但是他又会报另外 uncategorized 下的另一个文件的错，所以需要删除 uncategorized 整个目录，大家根据自己的情况删除就行了，我这个目录下的文件都是根据 source/_posts/ 生成的，删除之后再执行命令 <code>hexo g</code> 会重新生成的~</p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>newpaper</title>
    <url>/uncategorized/newpaper/</url>
    <content><![CDATA[<p>my first blog!!<br>I’m so excited!!!</p>
]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>解决方法：浏览器账号密码自动保存</title>
    <url>/uncategorized/web%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h3 id="浏览器账号密码自动保存"><a href="#浏览器账号密码自动保存" class="headerlink" title="浏览器账号密码自动保存"></a>浏览器账号密码自动保存</h3><p>在用户在web页面登录时，浏览器会问用户是否保存账号密码，如果用户点击保存，那么在下次登录的时候可能会出现下面两种情况：</p>
<ol>
<li>账号密码手动回填</li>
</ol>
<p><img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20201027102122167.png" alt="image-20201027102122167"></p>
<ol start="2">
<li><p>账号密码自动回填</p>
<p><img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20201027102412090.png" alt="image-20201027102412090"></p>
</li>
</ol>
<p>如果用户在公共电脑上顺手点了保存，那么之后使用此电脑的人就很容易获取到用户的账号信息。虽然这样的设计方便了用户登录，但也很容易导致安全隐患。</p>
<h4 id="页面的处理方式"><a href="#页面的处理方式" class="headerlink" title="页面的处理方式"></a>页面的处理方式</h4>]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
</search>
